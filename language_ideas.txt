# Day 1: Postgres 00:11:38 / 00:30:35
#   On AoC clock; this was likely real times
# Day 2: dc 04:47:34 / 00:06:09
#   On AoC clock; I think this was continuous from 5am, though I spent
#   10 minutes getting out of bed during this.
# Day 3: APL (dyalog) 05:45:00 / 01:35:00
#   AoC 08:41:01 / 10:14:45; woke late and only got APL working ater
#   7am. I linked tryapl at 07:57 (+2:57) so I'm taking a bit before
#   that as a starting point.. I listed "a bit under 9 hours" as solve
#   time.
# Day 4: Befunge 03:40:00 / 02:05:00
#   AoC 03:54:49 / 08:01:58; this includes some time getting up, plus
#   building a local interpreter. The second part included around 2
#   hours of work meetings plus some work in addition; I think I
#   solved it in an additional 1-2 hours at lunch.
# Day 5: jq 01:27:27 / 01:10:21
#   AoC 01:27:27 / 02:47:48; I think I got out of bed after part 1 so
#   subtracted an extra 10 mins.
# Day 6: GAP 03:00:00 approx
#   AoC 00:25:12 / 00:26:00. This was Python. The GAP stuff took 3
#   hours more, including figuring out how to run code in it.
# Day 7: Bash 01:30:00 / 00:44:41
#   AoC 15:31:09 / 16:15:50; I didn't start until later on. I think I
#   started at 18:58, about 14 hours late. Used that as start time. A
#   lot of time was spent debugging regular expressions.
# Day 8: PowerShell 02:00:00 / 01:10:00
#   AoC 05:03:05 / 15:20:43; started 2h late on part 1 and did a 1h
#   bike ride plus shower during it so about 2h. Second part took
#   about 01:10 on top.
# Day 9: Forth (gforth) 04:50:00 / 02:14:00
#   AoC 08:39:15 / 12:22:57; continuous for part 1, but started 02:37
#   late, and had breakfast delaying starting until 03:48, so 04:50 or
#   so. 11:08 late starting second part, so 02:14 for this.
# Day 10: Prolog (swi-prolog) 02:10:00 / 03:12:00
#   AoC 05:26:38 / 11:32:40; started looking for an interpreter at
#   08:08, installed swi-prolog at 08:20 -- so, call it 2 hours. Did a
#   lot of thinking about approach for part 2 while riding bike,
#   started implementation at 13:20 or so (08:20), so about 03:12 for
#   second part. I could have done better if I just went for the
#   inefficient approach, but I got really tied up in logic errors
#   until I finally got out my whiteboard.
# Day 11: Haskell 02:04:00 / 00:06:10
#   07:04:40 / 07:10:50; Start time 07:54 (10 mins thinking at 6am).
#   finished 12:11 (second part). Blocks of 1h6, (45m off), 35m, (77m off),
#   10m, (7m off), 8m.
# Day 12: Elixir 00:55:27 / 00:42:00
#   03:22:53 / 09:07:32 AoC; Elixir installed 07:27:26 (02:27:26). Did second
#   part after lunch. Actually got an answer to part 2 at 26 minutes, but my
#   code didn't include the "join with `?`" part of the spec, which caused me
#   to have to debug it for 15 minutes before rereading the spec and noticing
#   my error.
# Day 13: Perl 00:56:22 / 00:18:52
#   00:56:22 / 01:15:14 AoC; Woke up early for this one, so wasted little time.
#   Except by trying to use regular expressions to solve it. That wasted some
#   time with debugging. Second part took a bit of thinking but worked first
#   time.
# Day 14: C 00:27:00 / 01:04:00
#   02:09:28 / 03:12:16 AoC; pretty much continuous from 06:42 (01:42).
# Day 15: Bywater BASIC 01:15:18 / 01:22:22
#   02:32:58 / 03:45:20 AoC; started at 06:17:40 (01:17:40). Spent 10 minutes
#   faffing with "Brandy", which claims to be a BBC BASIC interpreter but
#   actually just corrupted my terminal. Had a 10-15 minute debug incident
#   where I copy/pasted the last-but-one total and wondered why it was wrong.
#   Also, Bywater BASIC doesn't support strings longer than 5000 characters
#   (it'll segfault).
# Day 16: QLogo 02:53:58 / 02:19:27
#   03:56:43 / 06:16:10 AoC; started at 06:02:45 (01:02:45). Took me 10 minutes
#   to get a working interpreter and a lot more to work through the horrible
#   IO. Ah well, it's another evil language down.
# Day 17: vimscript 01:21:39 / 00:25:51 (00:30:00)
#   03:16:39 / 03:41:30 AoC (03:46:39 to fix an off-by-one error I literally
#   coded in). I woke up about 06:18 and had read problem by 06:29. Began
#   getting out of bed at 06:33, was online at 06:58, picked vimscript 07:00 or
#   so, and apparently had figured out "readfile" and "echo" by 07:05. Let's
#   say I started at 06:55 (01:55:00). No breaks for solve.
# Day 18: Ruby 00:47:10 / 00:07:30
#   02:04:57 / 02:12:27 AoC. 06:17:47 started checking problem 06:19:54 picked
#   language. Let's take the first time, which is 01:17:47 off the clock.
# Day 19: C++ 01:27:30 / 01:45:34
#   02:38:30 / 03:24:04. Started 06:11, continuous.
# Day 20: Erlang 01:24:51 / 04:00:00??
#   03:10:43 / 12:29:16 AoC. Office day. Started 06:45:52 stopped part2
#   09:07:49. Distractedly worked on during work, mostly after around 14:00,
#   finished at work. Language not a major issue at all; used as a joker.
# Day 21: Rust 01:30:00 / 04:00:00?
#   06:08:14 / 18:27:04 AoC. Worked on distractedly on the train, around 09:16.
#   Used only offline docs due to situation, which was a bit of a crippler. Had
#   something that read input and found S by 09:53, which was also a train
#   change. 10:30 restart and submitted 11:08. Part 2 was much more of a mare.
#   Spent some time thinking during the day but started proper around 17:40.
#   Lots of train changes etc., but probably a clean run again from about 21:00
#   to 23:27. I spent a huge amount of time trying to nderstand why my code
#   didn't compile, and very little time trying to work out why the algorithm
#   was wrong. The offline docs are great.
# Day 22: Elisp^WPython ??:??:?? / 00:48:32
#   07:25:10 / 08:13:42 AoC. Started 06:07. Got something that at least read
#   the input by about 08:00. I eventually gave up at 11:50 or so. Started,
#   distractedly, in Python, around midday. I guess I _did_ use Python, after
#   all.
# Day 23: 01:58:36 (Elisp) / ??:??:?? (Python)
#   05:45:50 / 17:57:09 AoC. Started around 08:47:14 (03:47:14). Had to take a
#   break and didn't count hours. Time is from Python script, but after
#   enabling optimisations into the wee hours, got the Elisp to run verbatim in
#   just over an hour -- likely less time than it took to get the Python done.
#   Python code is faster and has simpler algorithm learned from Elisp effort.
# Day 24: Java 01:44:45 / 36:00:00
#   05:14:45 / >24h AoC. Started maybe 09:00 (04:00:00)? No timestamp. After
#   08:30. Had a massive wrestly getting this done and probably really used
#   around 15-20 hours on it. Java was not the issue.
# Day 25: Bash (duplicate, but meh): 00:40:48 / 00:00:31
#   18:03:29 / 18:04:01 AoC. Had a brief peek in the morning, decided to look
#   in GraphViz but save 'til after Day 24. Started proper at 22:22:41
#   (17:22:41).

Probably a massive grind:

R
CMAKE
Parrot?
PostScript
Q / ??? some sort of array thing. (APL done)
Rail (Befunge done)

Probably not that bad:

JavaScript
Raku?
Clojure / Scheme
